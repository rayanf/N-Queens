{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-11-18T12:52:55.040149Z",
     "start_time": "2021-11-18T12:52:52.067551Z"
    }
   },
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import pandas as pd\n",
    "import random\n",
    "import matplotlib.pyplot as plt\n",
    "from sklearn import preprocessing"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-11-18T12:52:55.164328Z",
     "start_time": "2021-11-18T12:52:55.078611Z"
    }
   },
   "outputs": [],
   "source": [
    "class QueenGenetic: \n",
    "    def __init__(self,init_pop_size, board_size):\n",
    "        self.init_pop_size = init_pop_size\n",
    "        self.pop_size = init_pop_size\n",
    "        self.board_size = board_size\n",
    "        self.total_cost = 0\n",
    "        self.fitness_arr = np.zeros((self.pop_size,1))\n",
    "        self.fitness_prob = np.zeros((self.pop_size,1))\n",
    "        \n",
    "    def PopulationInit(self):\n",
    "        rand_pop = np.array(random.sample(range(self.board_size),self.board_size))\n",
    "        self.pop = np.array(rand_pop)\n",
    "        for index in range(self.init_pop_size-1):\n",
    "            rand_pop = np.array(random.sample(range(self.board_size),self.board_size))\n",
    "            self.pop = np.vstack((self.pop, rand_pop))\n",
    "        #self.new_pop = np.array(self.pop) \n",
    "            \n",
    "    #Fitness function: Calculates the overall cost\n",
    "    def Fitness(self):\n",
    "        self.fitness_arr = np.zeros((self.pop_size,1))\n",
    "        #Check diagonal and reverse-diagonal conflicts\n",
    "        for ii in range(self.pop_size): \n",
    "            curr_pop = self.pop[ii,:]\n",
    "            curr_pop_arr = np.zeros((self.board_size,self.board_size))\n",
    "            curr_pop_arr[np.arange(self.board_size), curr_pop] = 1\n",
    "            for jj in range(self.board_size):\n",
    "                diag_ones = np.count_nonzero(curr_pop_arr.diagonal(jj))\n",
    "                rev_diag_ones = np.count_nonzero(np.fliplr(curr_pop_arr).diagonal(jj))\n",
    "                if diag_ones > 1:\n",
    "                    self.fitness_arr[ii] += (diag_ones) * (diag_ones - 1)/ 2\n",
    "                if rev_diag_ones > 1:\n",
    "                    self.fitness_arr[ii] += (rev_diag_ones) * (rev_diag_ones - 1)/ 2\n",
    "            #Exponential is used to enhance parents with higher fitness values to be matched\n",
    "            #Other approaches may be applied\n",
    "            #If exponential returns 0, then optimal situation reached\n",
    "            #Else then, more conflict will result in an exponential decrease of fitness value\n",
    "            #+++Less fitness value for more conflicts => Less chance to be selected as parents\n",
    "            self.fitness_arr[ii] = 1/(np.exp(self.fitness_arr[ii]))\n",
    "        norm = np.sum(self.fitness_arr)\n",
    "        self.fitness_prob = self.fitness_arr / norm\n",
    "        self.fitness_prob = self.fitness_prob.reshape((self.fitness_prob.shape[0],))\n",
    "        \n",
    "        return self.fitness_arr\n",
    "    \n",
    "    def Permutation(self):\n",
    "        rand_ind = random.sample(range(self.board_size), 2)\n",
    "        min_rand_ind = np.min(rand_ind)\n",
    "        max_rand_ind = np.max(rand_ind)\n",
    "        diff = max_rand_ind - min_rand_ind\n",
    "        while diff <= 1:\n",
    "            rand_ind = random.sample(range(self.board_size), 2)\n",
    "            min_rand_ind = np.min(rand_ind)\n",
    "            max_rand_ind = np.max(rand_ind)\n",
    "            diff = max_rand_ind - min_rand_ind\n",
    "        return min_rand_ind, max_rand_ind, diff\n",
    "    \n",
    "    # Order 1 Crossover function\n",
    "    # Every generation contains k new members\n",
    "    # Parent choice counter check \n",
    "    def Crossover(self, k):  \n",
    "        \n",
    "        parents_ind = np.random.choice(np.arange(self.pop_size), 2, replace = False, p = self.fitness_prob)\n",
    "        parents = np.array([self.pop[parents_ind[0]], self.pop[parents_ind[1]]])\n",
    "        min_rand_ind, max_rand_ind, diff = self.Permutation()\n",
    "        seq = parents[0,min_rand_ind:max_rand_ind] \n",
    "        parents_1 = parents[1][~np.isin(parents[1],seq)]\n",
    "        new_pop = np.concatenate((parents_1[0:min_rand_ind],seq), axis=None)\n",
    "        new_pop = np.concatenate((new_pop, parents_1[min_rand_ind:]), axis=None)\n",
    "        \n",
    "        for ii in range(k-1):\n",
    "            parents_ind = np.random.choice(np.arange(self.pop_size), 2, replace = False, p = self.fitness_prob)\n",
    "            parents = np.array([self.pop[parents_ind[0]], self.pop[parents_ind[1]]])\n",
    "            min_rand_ind, max_rand_ind, diff = self.Permutation()\n",
    "            seq = parents[0,min_rand_ind:max_rand_ind]            \n",
    "            parents_1 = parents[1][~np.isin(parents[1],seq)]\n",
    "            child = np.concatenate((parents_1[0:min_rand_ind],seq), axis=None)\n",
    "            child = np.concatenate((child, parents_1[min_rand_ind:self.board_size]), axis=None)\n",
    "            new_pop = np.vstack((new_pop, child))\n",
    "            \n",
    "        self.pop = np.copy(new_pop)\n",
    "        self.pop_size = k\n",
    "        \n",
    "    # Mutation: Single and double mutation \n",
    "    def Mutation(self):\n",
    "        for ii in range(self.pop_size):\n",
    "            prob = np.random.uniform()\n",
    "            #Double mutation\n",
    "            if prob < 0.2:\n",
    "                rand_ind = random.sample(range(self.board_size), 4)\n",
    "                temp = self.pop[ii, rand_ind[1]]\n",
    "                self.pop[ii, rand_ind[1]] = self.pop[ii, rand_ind[0]]\n",
    "                self.pop[ii, rand_ind[0]] = temp\n",
    "                \n",
    "                temp = self.pop[ii, rand_ind[3]]\n",
    "                self.pop[ii, rand_ind[3]] = self.pop[ii, rand_ind[2]]\n",
    "                self.pop[ii, rand_ind[2]] = temp\n",
    "            #Single Mutation    \n",
    "            elif prob < 0.4:\n",
    "                rand_ind = random.sample(range(self.board_size), 2)\n",
    "                temp = self.pop[ii, rand_ind[1]]\n",
    "                self.pop[ii, rand_ind[1]] = self.pop[ii, rand_ind[0]]\n",
    "                self.pop[ii, rand_ind[0]] = temp\n",
    "                \n",
    "        \n",
    "        \n",
    "        \n",
    "        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-11-18T12:53:15.360175Z",
     "start_time": "2021-11-18T12:52:55.185081Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Please enter size of initial population for N-Queens: 100\n",
      "Please enter size of board for N-Queens: 100\n",
      "0 th Generation with Average Fitness value = 2.6643754295854863e-10 and Maximum Fitness Value = 1.522997974471263e-08\n",
      "1 th Generation with Average Fitness value = 1.3110277926299884e-08 and Maximum Fitness Value = 1.670170079024566e-05\n",
      "2 th Generation with Average Fitness value = 5.807340994091007e-07 and Maximum Fitness Value = 0.00012340980408667953\n",
      "3 th Generation with Average Fitness value = 2.848056914903673e-05 and Maximum Fitness Value = 0.0024787521766663585\n",
      "4 th Generation with Average Fitness value = 0.00010908667479686156 and Maximum Fitness Value = 0.006737946999085467\n",
      "5 th Generation with Average Fitness value = 0.0007089042440573024 and Maximum Fitness Value = 0.018315638888734182\n",
      "6 th Generation with Average Fitness value = 0.0025688776985076543 and Maximum Fitness Value = 0.049787068367863944\n",
      "7 th Generation with Average Fitness value = 0.004569108416439656 and Maximum Fitness Value = 0.36787944117144233\n",
      "8 th Generation with Average Fitness value = 0.010621765548220759 and Maximum Fitness Value = 1.0\n"
     ]
    }
   ],
   "source": [
    "# N-Queens: Main constraint -> Columns are already set, only row-wise and diagonal conflicts\n",
    "\n",
    "init_pop_size = int(input('Please enter size of initial population for N-Queens: '))\n",
    "init_board_size = int(input('Please enter size of board for N-Queens: '))\n",
    "board = QueenGenetic(init_pop_size, init_board_size)\n",
    "board.PopulationInit()\n",
    "\n",
    "gen = 0\n",
    "fitness_arr = board.Fitness()\n",
    "while True :\n",
    "    print(gen, \"th Generation with Average Fitness value =\",np.mean(fitness_arr),\"and Maximum Fitness Value =\", np.max(fitness_arr))\n",
    "    if np.max(fitness_arr) == 1:\n",
    "        break\n",
    "    board.Crossover(2048)\n",
    "    board.Mutation()\n",
    "    gen += 1\n",
    "    fitness_arr = board.Fitness()\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-11-17T20:16:09.816089Z",
     "start_time": "2021-11-17T20:15:34.514087Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Please enter size of initial population for N-Queens: 10000\n",
      "Please enter size of board for N-Queens: 100\n",
      "0 th Generation with Average Fitness value = 2.277426578644622e-09 and Maximum Fitness Value = 6.14421235332821e-06\n",
      "1 th Generation with Average Fitness value = 3.1362942384851087e-07 and Maximum Fitness Value = 0.00012340980408667953\n",
      "2 th Generation with Average Fitness value = 6.888346064504963e-06 and Maximum Fitness Value = 0.0009118819655545162\n",
      "3 th Generation with Average Fitness value = 4.794443529612316e-05 and Maximum Fitness Value = 0.006737946999085467\n",
      "4 th Generation with Average Fitness value = 0.0002624856058002356 and Maximum Fitness Value = 0.018315638888734182\n",
      "5 th Generation with Average Fitness value = 0.0012244165580954944 and Maximum Fitness Value = 0.018315638888734182\n",
      "6 th Generation with Average Fitness value = 0.0035002555157400764 and Maximum Fitness Value = 0.1353352832366127\n",
      "7 th Generation with Average Fitness value = 0.006654104412115513 and Maximum Fitness Value = 0.1353352832366127\n",
      "8 th Generation with Average Fitness value = 0.011771717439069112 and Maximum Fitness Value = 0.36787944117144233\n",
      "9 th Generation with Average Fitness value = 0.022090126109008363 and Maximum Fitness Value = 0.36787944117144233\n",
      "10 th Generation with Average Fitness value = 0.03500785084171337 and Maximum Fitness Value = 1.0\n"
     ]
    }
   ],
   "source": [
    "# N-Queens: Main constraint -> Columns are already set, only row-wise and diagonal conflicts\n",
    "\n",
    "init_pop_size = int(input('Please enter size of initial population for N-Queens: '))\n",
    "init_board_size = int(input('Please enter size of board for N-Queens: '))\n",
    "board = QueenGenetic(init_pop_size, init_board_size)\n",
    "board.PopulationInit()\n",
    "\n",
    "gen = 0\n",
    "fitness_arr = board.Fitness()\n",
    "while True :\n",
    "    print(gen, \"th Generation with Average Fitness value =\",np.mean(fitness_arr),\"and Maximum Fitness Value =\", np.max(fitness_arr))\n",
    "    if np.max(fitness_arr) == 1:\n",
    "        break\n",
    "    board.Crossover(2048)\n",
    "    board.Mutation()\n",
    "    gen += 1\n",
    "    fitness_arr = board.Fitness()\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "start_time": "2021-11-18T14:36:55.903Z"
    }
   },
   "outputs": [],
   "source": [
    "import random\n",
    "from math import exp\n",
    "import time\n",
    "from copy import deepcopy\n",
    "\n",
    "N_QUEENS = 10000\n",
    "TEMPERATURE = 140000\n",
    "\n",
    "\n",
    "def threat_calculate(n):\n",
    "    '''Combination formular. It is choosing two queens in n queens'''\n",
    "    if n < 2:\n",
    "        return 0\n",
    "    if n == 2:\n",
    "        return 1\n",
    "    return (n - 1) * n / 2\n",
    "\n",
    "\n",
    "def create_board(n):\n",
    "    '''Create a chess boad with a queen on a row'''\n",
    "    chess_board = {}\n",
    "    temp = list(range(n))\n",
    "    random.shuffle(temp)  # shuffle to make sure it is random\n",
    "    column = 0\n",
    "\n",
    "    while len(temp) > 0:\n",
    "        row = random.choice(temp)\n",
    "        chess_board[column] = row\n",
    "        temp.remove(row)\n",
    "        column += 1\n",
    "    del temp\n",
    "    return chess_board\n",
    "\n",
    "\n",
    "def cost(chess_board):\n",
    "    '''Calculate how many pairs of threaten queen'''\n",
    "    threat = 0\n",
    "    m_chessboard = {}\n",
    "    a_chessboard = {}\n",
    "\n",
    "    for column in chess_board:\n",
    "        temp_m = column - chess_board[column]\n",
    "        temp_a = column + chess_board[column]\n",
    "        if temp_m not in m_chessboard:\n",
    "            m_chessboard[temp_m] = 1\n",
    "        else:\n",
    "            m_chessboard[temp_m] += 1\n",
    "        if temp_a not in a_chessboard:\n",
    "            a_chessboard[temp_a] = 1\n",
    "        else:\n",
    "            a_chessboard[temp_a] += 1\n",
    "\n",
    "    for i in m_chessboard:\n",
    "        threat += threat_calculate(m_chessboard[i])\n",
    "    del m_chessboard\n",
    "\n",
    "    for i in a_chessboard:\n",
    "        threat += threat_calculate(a_chessboard[i])\n",
    "    del a_chessboard\n",
    "\n",
    "    return threat\n",
    "\n",
    "\n",
    "def simulated_annealing():\n",
    "    '''Simulated Annealing'''\n",
    "    solution_found = False\n",
    "    answer = create_board(N_QUEENS)\n",
    "\n",
    "    # To avoid recounting when can not find a better state\n",
    "    cost_answer = cost(answer)\n",
    "\n",
    "    t = TEMPERATURE\n",
    "    sch = 0.999\n",
    "\n",
    "    while t > 0:\n",
    "        t *= sch\n",
    "        successor = deepcopy(answer)\n",
    "        while True:\n",
    "            index_1 = random.randrange(0, N_QUEENS - 1)\n",
    "            index_2 = random.randrange(0, N_QUEENS - 1)\n",
    "            if index_1 != index_2:\n",
    "                break\n",
    "        successor[index_1], successor[index_2] = successor[index_2], \\\n",
    "            successor[index_1]  # swap two chosen queens\n",
    "        delta = cost(successor) - cost_answer\n",
    "        if delta < 0 or random.uniform(0, 1) < exp(-delta / t):\n",
    "            answer = deepcopy(successor)\n",
    "            cost_answer = cost(answer)\n",
    "        if cost_answer == 0:\n",
    "            solution_found = True\n",
    "            print_chess_board(answer)\n",
    "            break\n",
    "    if solution_found is False:\n",
    "        print(\"Failed\")\n",
    "\n",
    "\n",
    "def print_chess_board(board):\n",
    "    '''Print the chess board'''\n",
    "    for column, row in board.items():\n",
    "        print(\"{} => {}\".format(column, row))\n",
    "\n",
    "\n",
    "def main():\n",
    "    start = time.time()\n",
    "    simulated_annealing()\n",
    "    print(\"Runtime in second:\", time.time() - start)\n",
    "\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.0"
  },
  "varInspector": {
   "cols": {
    "lenName": 16,
    "lenType": 16,
    "lenVar": 40
   },
   "kernels_config": {
    "python": {
     "delete_cmd_postfix": "",
     "delete_cmd_prefix": "del ",
     "library": "var_list.py",
     "varRefreshCmd": "print(var_dic_list())"
    },
    "r": {
     "delete_cmd_postfix": ") ",
     "delete_cmd_prefix": "rm(",
     "library": "var_list.r",
     "varRefreshCmd": "cat(var_dic_list()) "
    }
   },
   "types_to_exclude": [
    "module",
    "function",
    "builtin_function_or_method",
    "instance",
    "_Feature"
   ],
   "window_display": false
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
